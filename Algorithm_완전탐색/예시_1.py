탐색문제는 반복문 또는 재귀사용
재귀는 시작과 종료조건 고려 

문제) 패킬리 레스토랑에 가서, 여러 개의 테이블에 사람을 나누어 앉게 하려고 합니다. 
이때, 한사람만 앉는 테이블이 없게 그룹을 지어야 합니다. 인원수를 나누는 패턴만 구하면 되며
누가 어디에 앉는지 등은 고려하지 않습니다. 예를 들어 6명이라면, 다음과 같은 4가지가 됩니다.

2명+2명+2명
2명+4명
3명+3명
6명

한 개의 테이블에 앉을 수 있는 사람은 최대 10명입니다. 100명이 하나 이상의 테이블에 나누어 앉는 패턴은 ?


(재귀함수 이용, 재귀함수 형태를 볼 수 있음)

앉힐수있는최소사람수=2
앉힐수있는최대사람수=10
전체사람의수=100
count=0

# 트리 : 노드에 적은 값/엣지에 적은 값이 중요함 
def 문제(남은사람수, 앉힌사람수):
    global count 
    # 종료 조건 
    if 남은사람수 <0
       -> 제대로 된 것 아님
       return 
    if 남은 사람수 ==0: 
       #유효한 경우
       count+=1
       return 
    #재귀 호출
    #2~10 -> 이건 엣지에 쓰여짐
    for i in range(앉힌사람수,안힐수있는최대사람수+1):
        문제(남은사람수-i,i)
    return 
    
 문제(전체사람의수, 앉힐수있는최소사람수)
 print(count)



앉힐수있는최소사람수=2
앉힐수있는최대사람수=10
전체사람의수=100
count=0

# 트리 : 노드에 적은 값/엣지에 적은 값이 중요함 
def 문제((남은사람수, 앉힌사람수)):
    if 남은사람수 <0
       -> 제대로 된 것 아님
       return 0
    if 남은 사람수 ==0: 
       #유효한 경우
       return 1
    count =0 
    for i in range(앉힌사람수, 앉힐수있는최대사람수+1):
        count+=문제(남은사람수-i,i)
    return count
    
print(문제(전체사람의수, 앉힐수있는최소사람수))

앉힐수있는최소사람수 = 2
앉힐수있는최대사람수 = 10
전체사람의수 = 100
memo = {}

def 문제(남은사람수, 앉힌사람수):
    key = str((남은사람수, 앉힌사람수))
    # 종료 조건
    if key in memo:
        return memo[key]
    if 남은사람수 < 0:
        return 0 # 무효하니 0을 리턴
    if 남은사람수 == 0:
        return 1 # 유효하니 수를 세면 되서 1을 리턴
    # 재귀 처리
    count = 0
    for i in range(앉힌사람수, 앉힐수있는최대사람수 + 1):
        count += 문제(남은사람수 - i, i)
    # 메모화 처리
    memo[key] = count
    # 종료
    return count
    
print(문제(전체사람의수, 앉힐수있는최소사람수))

출처 : https://gist.github.com/rintiantta/39e1aa642a25da30021343b30f6ccb0f
