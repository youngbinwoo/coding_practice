1) 중위 표기법과 후위 표기법
   중위 표기법: (A+B)*(C+D)  : 연산자가 피연산자들의 사이에 위치
                  1  3  2 
   후위 표기법 : 연산자가 피연산자들의 뒤에 위치
           A B + C D + * (*앞에 있는 A와B의 합, C와D의 합을 곱한다)
               1     2 3
   
2) 중위 표현식 -> 후위 표현식

   (중위) A * B + C       (중위) A + B * C
             ^                      ^
   (후위) A B * C +       (후위) A B C * +  
   
3) 괄호의 처리
   
   (중위) (A + B) * C        (중위) A * (B + C)       
             ^                      
   (후위) A B + C *          (후위) A B C + *   
   
   
   여는 괄호는 스택에 push, 닫는 괄호를 만나면 여는 괄호가 나올 때까지 pop
   
   연산자를 만났을 때, 여는 괄호 너머까지 pop 하지 않도록 여는 괄호의 우선순위는 가장 낮게 설정
   
4) 알고리즘 설계 
   (1) 연산자의 우선순위 설정
   (2) 피연산자이면 그냥 출력 
       '('이면 스택에 push
       ')'이면 '('이 나올 때까지 스택에서 pop, 출력
       연산자이면 스택에서 이보다 높거나 같은 우선순위 것들을 pop, 출력
          그리고 이 연산자는 스택에 push
     스텍에 남아 있는 연산자는 모두 pop, 출력     
        -> 같은 우선순위는 왼쪽부터 먼저 계산
        
5) 코드의 구현_힌트
   스택의 맨 위에 있는 연산자와의 우선순위 비교  :  스택의 peek() 연산 이용
   스택에 남아 있는 연산자 모두 pop() 하는 순환문  : while not opStack.isEmpty():
        
        
6) 문제

중위 표기법을 따르는 수식 S 가 인자로 주어질 때,
이 수식을 후위 표기법을 따르는 수식으로 변환하여 반환하는 함수 solution() 을 완성하세요.
인자로 주어지는 수식 문자열 S 는 영문 대문자 알파벳 한 글자로 이루어지는 
변수 A - Z 까지와 4칙연산을 나타내는 연산자 기호 +, -, *, /, 그리고 여는 괄호와 닫는 괄호 (, ) 로 이루어져 있으며
공백 문자는 포함하지 않는 것으로 가정합니다. 또한, 올바르게 구성되지 않은 수식은 인자로 주어지지 않는다고 가정합니다. 
(수식의 유효성은 검증할 필요가 없습니다.)
문제에서 미리 주어진, 연산자의 우선순위를 표현한 python dict 인 prec 을 활용할 수 있습니다.
또한, 스택의 기초 강의에서 이미 구현한, 
배열을 이용한 스택의 추상적 자료 구조 코드가 이미 포함되어 있으므로 그대로 이용할 수 있습니다.
(참고) 테스트 케이스를 보완하여 문제가 2019년 9월 24일에 수정되었습니다.

답)

   

   
